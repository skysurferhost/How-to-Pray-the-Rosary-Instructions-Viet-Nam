<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rosary PDF Viewer United States</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #111;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }

  /* ===== TOOLBAR ===== */
  .toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 44px;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    z-index: 1000;
  }

  .toolbar button {
    background: #fff;
    border: none;
    padding: 6px 12px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }

  /* ===== VIEWER ===== */
  #viewer-container {
    position: absolute;
    top: 44px;
    bottom: 44px;
    left: 0;
    right: 0;

    /* default: pannable */
    overflow: hidden;
    touch-action: none;
  }

  /* ‚úÖ Scroll mode (vertical scrolling through the page) */
  #viewer-container.scroll-enabled {
    overflow-y: auto;
    overflow-x: hidden;

    /* allow native scrolling */
    touch-action: pan-y;
    -webkit-overflow-scrolling: touch;
  }

  #viewer {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    cursor: grab;

    /* üöÄ PERFORMANCE BOOST */
    will-change: transform;
    transform: translateZ(0);
  }

  /* When scrolling is enabled, viewer should behave like normal content */
  #viewer-container.scroll-enabled #viewer {
    position: relative;
    left: 50%;
    transform: translateX(-50%) scale(var(--scroll-scale, 1));
    cursor: default;
    will-change: auto;
  }

  #viewer.dragging {
    cursor: grabbing;
  }

  canvas {
    display: block;
    margin: 0 auto;
  }

  /* ===== PAGE NAV ===== */
  .page-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 44px;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 14px;
    z-index: 1000;
    color: #fff;
    font-size: 14px;
  }

  .page-nav button {
    background: #fff;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
  }

  @media (max-width: 768px) {
    .toolbar, .page-nav {
      height: 50px;
    }
    #viewer-container {
      top: 50px;
      bottom: 50px;
    }
  }
</style>
</head>

<body>

<div class="toolbar">
  <button onclick="zoomOut()">‚àí</button>
  <button onclick="zoomIn()">+</button>
  <button onclick="toggleFullscreen()">‚§¢ Fullscreen</button>
</div>

<div id="viewer-container">
  <div id="viewer"></div>
</div>

<div class="page-nav">
  <!-- ‚úÖ NEW BUTTON on the left side of the left arrow -->
  <button id="scrollToggleBtn" onclick="toggleScroll()">Enable Scrolling</button>

  <button onclick="prevPage()">‚óÄ</button>
  <span id="pageIndicator">Page 1</span>
  <button onclick="nextPage()">‚ñ∂</button>
</div>

<script>
  const url = './How-to-Pray-the-Rosary-Instructions-Viet-Nam.pdf';

  let pdfDoc = null;
  let pageNum = 1;
  let totalPages = 0;

  /* üîç Default zoom ‚Äî more zoomed out on phones */
  let scale = window.innerWidth < 768 ? 0.3 : 0.35;
  let posX = 0;
  let posY = 0;

  /* üéØ Smoothed transform targets */
  let targetScale = scale;
  let targetX = posX;
  let targetY = posY;
  let rafPending = false;

  const viewer = document.getElementById('viewer');
  const container = document.getElementById('viewer-container');
  const indicator = document.getElementById('pageIndicator');
  const scrollToggleBtn = document.getElementById('scrollToggleBtn');

  let scrollEnabled = false;

  pdfjsLib.getDocument(url).promise.then(pdf => {
    pdfDoc = pdf;
    totalPages = pdf.numPages;
    renderPage();
  });

  function renderPage() {
    viewer.innerHTML = '';
    pdfDoc.getPage(pageNum).then(page => {
      const viewport = page.getViewport({ scale: 1 });
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = viewport.width;
      canvas.height = viewport.height;

      page.render({ canvasContext: ctx, viewport });
      viewer.appendChild(canvas);

      indicator.textContent = `Page ${pageNum} / ${totalPages}`;

      // Reset based on current mode
      if (scrollEnabled) {
        applyScrollModeSizing();
        container.scrollTop = 0;
      } else {
        resetTransform();
      }
    });
  }

  function resetTransform() {
    targetScale = scale;
    targetX = (container.clientWidth - viewer.clientWidth * scale) / 2;
    targetY = 20;
    posX = targetX;
    posY = targetY;
    applyTransform();
  }

  /* üßà RAF-smoothed transform */
  function applyTransform() {
    if (rafPending) return;

    rafPending = true;
    requestAnimationFrame(() => {
      viewer.style.transform =
        `translate(${targetX}px, ${targetY}px) scale(${targetScale})`;
      rafPending = false;
    });
  }

  function zoomAtPoint(delta, cx, cy) {
    if (scrollEnabled) return; // ‚úÖ zoom disabled in scroll mode (keeps it simple + stable)

    const prevScale = targetScale;
    targetScale = Math.min(Math.max(0.25, targetScale + delta), 4);

    const dx = cx - targetX;
    const dy = cy - targetY;

    targetX -= dx * (targetScale / prevScale - 1);
    targetY -= dy * (targetScale / prevScale - 1);

    scale = targetScale;
    posX = targetX;
    posY = targetY;

    applyTransform();
  }

  /* üîò Buttons */
  function zoomIn() {
    zoomAtPoint(0.2, container.clientWidth / 2, container.clientHeight / 2);
  }

  function zoomOut() {
    zoomAtPoint(-0.2, container.clientWidth / 2, container.clientHeight / 2);
  }

  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }

  function nextPage() {
    if (pageNum < totalPages) {
      pageNum++;
      renderPage();
    }
  }

  function prevPage() {
    if (pageNum > 1) {
      pageNum--;
      renderPage();
    }
  }

  /* ‚úÖ Scroll mode toggle */
  function toggleScroll() {
    scrollEnabled = !scrollEnabled;

    if (scrollEnabled) {
      container.classList.add('scroll-enabled');
      scrollToggleBtn.textContent = "Disable Scrolling";

      // Reset transform state so it doesn't "fight" scroll layout
      applyScrollModeSizing();
      container.scrollTop = 0;
    } else {
      container.classList.remove('scroll-enabled');
      scrollToggleBtn.textContent = "Enable Scrolling";

      // Restore pan/zoom positioning
      resetTransform();
    }
  }

  function applyScrollModeSizing() {
    // Use the current "scale" as the scroll-mode scale, but clamp for sanity
    const scrollScale = Math.min(Math.max(scale, 0.25), 1.25);
    container.style.setProperty('--scroll-scale', scrollScale);

    // In scroll mode, we want the content centered with normal flow.
    // The CSS handles centering via translateX(-50%).
  }

  /* üñê PAN / DRAG */
  let dragging = false;
  let startX, startY;

  container.addEventListener('pointerdown', e => {
    if (scrollEnabled) return; // ‚úÖ allow normal scroll behavior
    dragging = true;
    viewer.classList.add('dragging');
    startX = e.clientX - targetX;
    startY = e.clientY - targetY;
  });

  window.addEventListener('pointermove', e => {
    if (!dragging || scrollEnabled) return;
    targetX = e.clientX - startX;
    targetY = e.clientY - startY;
    posX = targetX;
    posY = targetY;
    applyTransform();
  });

  window.addEventListener('pointerup', () => {
    dragging = false;
    viewer.classList.remove('dragging');
  });

  /* üñ± Desktop scroll zoom */
  container.addEventListener('wheel', e => {
    if (scrollEnabled) return; // ‚úÖ in scroll mode, wheel scrolls naturally
    e.preventDefault();
    const delta = e.deltaY < 0 ? 0.12 : -0.12;
    zoomAtPoint(delta, e.offsetX, e.offsetY);
  }, { passive: false });

  /* ü§è Mobile pinch zoom (stable) */
  let lastDistance = null;

  container.addEventListener('touchstart', e => {
    if (scrollEnabled) return;
    if (e.touches.length === 2) {
      lastDistance = getDistance(e.touches[0], e.touches[1]);
    }
  }, { passive: false });

  container.addEventListener('touchmove', e => {
    if (scrollEnabled) return;
    if (e.touches.length === 2 && lastDistance !== null) {
      e.preventDefault();

      const currentDistance = getDistance(e.touches[0], e.touches[1]);
      const delta = (currentDistance - lastDistance) * 0.0018;

      const rect = container.getBoundingClientRect();
      const centerX =
        (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
      const centerY =
        (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

      zoomAtPoint(delta, centerX, centerY);
      lastDistance = currentDistance;
    }
  }, { passive: false });

  container.addEventListener('touchend', () => {
    lastDistance = null;
  });

  function getDistance(t1, t2) {
    return Math.hypot(
      t2.clientX - t1.clientX,
      t2.clientY - t1.clientY
    );
  }

  /* üëÜ Double tap zoom */
  let lastTap = 0;
  container.addEventListener('click', () => {
    if (scrollEnabled) return;
    const now = Date.now();
    if (now - lastTap < 300) {
      zoomAtPoint(
        scale > 1 ? -scale + 0.85 : 0.7,
        container.clientWidth / 2,
        container.clientHeight / 2
      );
    }
    lastTap = now;
  });
</script>

</body>
</html>
