<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rosary PDF Viewer United States</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #111;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }

  /* ===== TOOLBAR ===== */
  .toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 44px;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    z-index: 1000;
  }

  .toolbar button {
    background: #fff;
    border: none;
    padding: 6px 12px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }

  /* ===== VIEWER ===== */
  #viewer-container {
    position: absolute;
    top: 44px;
    bottom: 44px;
    left: 0;
    right: 0;
    overflow: hidden;
    touch-action: none;
  }

  #viewer {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    cursor: grab;
    will-change: transform;
    transform: translateZ(0);
  }

  #viewer.dragging {
    cursor: grabbing;
  }

  canvas {
    display: block;
  }

  /* ===== BOTTOM BAR ===== */
  .page-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 44px;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 14px;
    z-index: 1000;
    color: #fff;
    font-size: 14px;
  }

  .page-nav button {
    background: #fff;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
  }

  @media (max-width: 768px) {
    .toolbar, .page-nav { height: 50px; }
    #viewer-container { top: 50px; bottom: 50px; }
  }
</style>
</head>

<body>

<div class="toolbar">
  <button onclick="zoomOut()">−</button>
  <button onclick="zoomIn()">+</button>
  <button onclick="toggleFullscreen()">⤢ Fullscreen</button>
</div>

<div id="viewer-container">
  <div id="viewer"></div>
</div>

<div class="page-nav">
  <button onclick="prevPage()">◀</button>
  <span id="pageIndicator">Loading…</span>
  <button onclick="nextPage()">▶</button>
</div>

<script>
  const url = './How-to-Pray-the-Rosary-Instructions-Viet-Nam.pdf';

  let pdfDoc = null;
  let totalPages = 0;

  // ✅ Start much more zoomed out
  let scale = window.innerWidth < 768 ? 0.24 : 0.30;
  const MIN_SCALE = 0.18;
  const MAX_SCALE = 4;

  // Pan position (continuous-pan)
  let x = 0;
  let y = 0;

  // Smooth draw
  let rafPending = false;

  // Page tracking (based on y position)
  let currentPage = 1;

  const viewer = document.getElementById('viewer');
  const container = document.getElementById('viewer-container');
  const indicator = document.getElementById('pageIndicator');

  let stripCanvas = null;
  let stripCtx = null;

  // Layout info for stacked pages
  let pageRects = [];  // [{page, yTop, yBottom}]
  let stripWidth = 0;
  let stripHeight = 0;
  const PAGE_GAP = 24; // space between pages in the big strip

  pdfjsLib.getDocument(url).promise.then(async pdf => {
    pdfDoc = pdf;
    totalPages = pdf.numPages;
    await renderContinuousPanStrip();
    resetView();
    updateIndicator();
  });

  async function renderContinuousPanStrip() {
    viewer.innerHTML = '';
    stripCanvas = document.createElement('canvas');
    stripCtx = stripCanvas.getContext('2d', { alpha: false });
    viewer.appendChild(stripCanvas);

    // First pass: measure using scale=1 viewports
    const viewports = [];
    stripWidth = 0;
    stripHeight = 0;
    pageRects = [];

    for (let i = 1; i <= totalPages; i++) {
      const page = await pdfDoc.getPage(i);
      const vp = page.getViewport({ scale: 1 });
      viewports.push(vp);
      stripWidth = Math.max(stripWidth, Math.ceil(vp.width));
    }

    // Total height = sum heights + gaps
    for (let i = 0; i < viewports.length; i++) {
      stripHeight += Math.ceil(viewports[i].height);
      if (i !== viewports.length - 1) stripHeight += PAGE_GAP;
    }

    stripCanvas.width = stripWidth;
    stripCanvas.height = stripHeight;

    // Fill background once
    stripCtx.fillStyle = "#111";
    stripCtx.fillRect(0, 0, stripWidth, stripHeight);

    // Second pass: render each page into the strip
    let yCursor = 0;
    for (let i = 1; i <= totalPages; i++) {
      const page = await pdfDoc.getPage(i);
      const vp = page.getViewport({ scale: 1 });

      // center page horizontally inside strip
      const xOffset = Math.floor((stripWidth - vp.width) / 2);

      // white page background for readability
      stripCtx.fillStyle = "#ffffff";
      stripCtx.fillRect(xOffset, yCursor, vp.width, vp.height);

      await page.render({
        canvasContext: stripCtx,
        viewport: vp,
        transform: [1, 0, 0, 1, xOffset, yCursor] // draw into strip
      }).promise;

      pageRects.push({
        page: i,
        yTop: yCursor,
        yBottom: yCursor + vp.height
      });

      yCursor += vp.height + PAGE_GAP;
    }
  }

  function resetView() {
    // Center strip in view at start (top-ish)
    x = (container.clientWidth - stripCanvas.width * scale) / 2;
    y = 20;
    applyTransform();
  }

  function applyTransform() {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      viewer.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
      rafPending = false;
      updateIndicator();
    });
  }

  function clampScale(s) {
    return Math.min(Math.max(MIN_SCALE, s), MAX_SCALE);
  }

  function zoomAtPoint(delta, cx, cy) {
    const prev = scale;
    scale = clampScale(scale + delta);

    // keep zoom centered around pointer location
    const dx = cx - x;
    const dy = cy - y;
    x -= dx * (scale / prev - 1);
    y -= dy * (scale / prev - 1);

    applyTransform();
  }

  function zoomIn() {
    zoomAtPoint(0.15, container.clientWidth / 2, container.clientHeight / 2);
  }

  function zoomOut() {
    zoomAtPoint(-0.15, container.clientWidth / 2, container.clientHeight / 2);
  }

  function toggleFullscreen() {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  }

  function updateIndicator() {
    if (!stripCanvas) return;

    // Estimate which page is at center of viewport
    const viewCenterY = (container.clientHeight / 2 - y) / scale;

    let best = 1;
    for (const r of pageRects) {
      if (viewCenterY >= r.yTop && viewCenterY <= r.yBottom) {
        best = r.page;
        break;
      }
      if (viewCenterY > r.yBottom) best = r.page;
    }
    currentPage = best;
    indicator.textContent = `Page ${currentPage} / ${totalPages}`;
  }

  function scrollToPage(n) {
    const r = pageRects.find(p => p.page === n);
    if (!r) return;

    // Move so that page top is visible near top
    const targetY = 20 - r.yTop * scale;
    y = targetY;
    applyTransform();
  }

  function nextPage() {
    if (currentPage < totalPages) scrollToPage(currentPage + 1);
  }

  function prevPage() {
    if (currentPage > 1) scrollToPage(currentPage - 1);
  }

  /* ===== PAN / DRAG (ALL DEVICES) ===== */
  let dragging = false;
  let startX, startY;

  container.addEventListener('pointerdown', e => {
    dragging = true;
    viewer.classList.add('dragging');
    startX = e.clientX - x;
    startY = e.clientY - y;
  });

  window.addEventListener('pointermove', e => {
    if (!dragging) return;
    x = e.clientX - startX;
    y = e.clientY - startY;
    applyTransform();
  });

  window.addEventListener('pointerup', () => {
    dragging = false;
    viewer.classList.remove('dragging');
  });

  /* ===== DESKTOP WHEEL ZOOM ===== */
  container.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY < 0 ? 0.10 : -0.10;
    zoomAtPoint(delta, e.offsetX, e.offsetY);
  }, { passive: false });

  /* ===== MOBILE PINCH ZOOM ===== */
  let lastDistance = null;

  container.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      lastDistance = getDistance(e.touches[0], e.touches[1]);
    }
  }, { passive: false });

  container.addEventListener('touchmove', e => {
    if (e.touches.length === 2 && lastDistance !== null) {
      e.preventDefault();
      const currentDistance = getDistance(e.touches[0], e.touches[1]);
      const delta = (currentDistance - lastDistance) * 0.0016;

      const rect = container.getBoundingClientRect();
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

      zoomAtPoint(delta, centerX, centerY);
      lastDistance = currentDistance;
    }
  }, { passive: false });

  container.addEventListener('touchend', () => {
    lastDistance = null;
  });

  function getDistance(t1, t2) {
    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
  }

  /* ===== DOUBLE TAP ZOOM ===== */
  let lastTap = 0;
  container.addEventListener('click', () => {
    const now = Date.now();
    if (now - lastTap < 300) {
      zoomAtPoint(
        scale > 1 ? -scale + 0.8 : 0.6,
        container.clientWidth / 2,
        container.clientHeight / 2
      );
    }
    lastTap = now;
  });

  // Expose for inline onclick
  window.zoomIn = zoomIn;
  window.zoomOut = zoomOut;
  window.toggleFullscreen = toggleFullscreen;
  window.nextPage = nextPage;
  window.prevPage = prevPage;
</script>

</body>
</html>
