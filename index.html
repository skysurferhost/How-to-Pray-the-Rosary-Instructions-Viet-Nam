<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rosary PDF Viewer United States</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #111;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }

  /* ===== TOOLBAR ===== */
  .toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 44px;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    z-index: 1000;
  }

  .toolbar button {
    background: #fff;
    border: none;
    padding: 6px 12px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }

  /* ===== VIEWER ===== */
  #viewer-container {
    position: absolute;
    top: 44px;
    bottom: 44px;
    left: 0;
    right: 0;
    overflow: hidden;     /* single-page mode */
    touch-action: none;   /* single-page mode */
  }

  /* Continuous scroll mode uses native scroll */
  #viewer-container.continuous {
    overflow-y: auto;
    overflow-x: hidden;
    touch-action: pan-y;
    -webkit-overflow-scrolling: touch;
  }

  #viewer {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    cursor: grab;

    will-change: transform;
    transform: translateZ(0);
  }

  /* In continuous mode, viewer becomes normal flow */
  #viewer-container.continuous #viewer {
    position: relative;
    top: 0;
    left: 0;
    cursor: default;
    transform: none !important;
    will-change: auto;
  }

  #viewer.dragging {
    cursor: grabbing;
  }

  /* Each page canvas */
  .pageCanvas {
    display: block;
    margin: 12px auto;
    background: #111;
  }

  /* ===== PAGE NAV ===== */
  .page-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 44px;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 14px;
    z-index: 1000;
    color: #fff;
    font-size: 14px;
  }

  .page-nav button {
    background: #fff;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
  }

  @media (max-width: 768px) {
    .toolbar, .page-nav { height: 50px; }
    #viewer-container { top: 50px; bottom: 50px; }
  }
</style>
</head>

<body>

<div class="toolbar">
  <button onclick="zoomOut()">−</button>
  <button onclick="zoomIn()">+</button>
  <button onclick="toggleFullscreen()">⤢ Fullscreen</button>
</div>

<div id="viewer-container">
  <div id="viewer"></div>
</div>

<div class="page-nav">
  <!-- ✅ Toggle continuous scroll -->
  <button id="continuousBtn" onclick="toggleContinuous()">Enable Continuous Scroll</button>

  <!-- Page buttons still available (works in both modes; in continuous mode it scrolls to that page) -->
  <button onclick="prevPage()">◀</button>
  <span id="pageIndicator">Page 1</span>
  <button onclick="nextPage()">▶</button>
</div>

<script>
  const url = './How-to-Pray-the-Rosary-Instructions-Viet-Nam.pdf';

  let pdfDoc = null;
  let totalPages = 0;

  // Single-page state
  let pageNum = 1;

  // Zoom scale (used in both modes)
  let scale = window.innerWidth < 768 ? 0.65 : 0.8; // continuous-friendly default
  const MIN_SCALE = 0.4;
  const MAX_SCALE = 2.5;

  // Single-page pan state
  let targetX = 0;
  let targetY = 0;
  let rafPending = false;

  // Mode
  let continuous = false;

  const viewer = document.getElementById('viewer');
  const container = document.getElementById('viewer-container');
  const indicator = document.getElementById('pageIndicator');
  const continuousBtn = document.getElementById('continuousBtn');

  pdfjsLib.getDocument(url).promise.then(pdf => {
    pdfDoc = pdf;
    totalPages = pdf.numPages;
    renderSinglePage(); // default
  });

  /* =========================
     RENDER: SINGLE PAGE
  ========================== */
  async function renderSinglePage() {
    continuous = false;
    container.classList.remove('continuous');
    continuousBtn.textContent = "Enable Continuous Scroll";

    viewer.innerHTML = '';
    const page = await pdfDoc.getPage(pageNum);

    const viewport = page.getViewport({ scale: 1 });
    const canvas = document.createElement('canvas');
    canvas.className = "pageCanvas";
    const ctx = canvas.getContext('2d');

    canvas.width = viewport.width;
    canvas.height = viewport.height;

    await page.render({ canvasContext: ctx, viewport }).promise;
    viewer.appendChild(canvas);

    indicator.textContent = `Page ${pageNum} / ${totalPages}`;

    // center page
    targetX = (container.clientWidth - canvas.width * scale) / 2;
    targetY = 20;
    applyTransform();
  }

  function applyTransform() {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      viewer.style.transform = `translate(${targetX}px, ${targetY}px) scale(${scale})`;
      rafPending = false;
    });
  }

  /* =========================
     RENDER: CONTINUOUS (ALL PAGES)
  ========================== */
  async function renderContinuous() {
    continuous = true;
    container.classList.add('continuous');
    continuousBtn.textContent = "Disable Continuous Scroll";

    viewer.innerHTML = '';

    // Render all pages stacked
    for (let i = 1; i <= totalPages; i++) {
      const page = await pdfDoc.getPage(i);
      const viewport = page.getViewport({ scale }); // scale applied here
      const canvas = document.createElement('canvas');
      canvas.className = "pageCanvas";
      canvas.dataset.page = String(i);

      const ctx = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      // render sequentially (stable)
      await page.render({ canvasContext: ctx, viewport }).promise;
      viewer.appendChild(canvas);
    }

    // show page indicator based on scroll position
    updateIndicatorFromScroll();
    container.scrollTop = 0;
  }

  function updateIndicatorFromScroll() {
    if (!continuous) return;

    const canvases = viewer.querySelectorAll('.pageCanvas');
    const top = container.scrollTop;

    let current = 1;
    canvases.forEach((c, idx) => {
      // page top relative to scroll container
      const y = c.offsetTop;
      if (y <= top + 30) current = idx + 1;
    });

    pageNum = current;
    indicator.textContent = `Page ${pageNum} / ${totalPages}`;
  }

  container.addEventListener('scroll', () => {
    if (continuous) updateIndicatorFromScroll();
  });

  /* =========================
     CONTINUOUS TOGGLE
  ========================== */
  function toggleContinuous() {
    if (!pdfDoc) return;
    if (continuous) {
      renderSinglePage();
    } else {
      renderContinuous();
    }
  }

  /* =========================
     ZOOM (BOTH MODES)
  ========================== */
  function zoomIn() {
    setScale(scale + 0.1);
  }
  function zoomOut() {
    setScale(scale - 0.1);
  }
  function setScale(newScale) {
    scale = Math.min(Math.max(MIN_SCALE, newScale), MAX_SCALE);

    if (continuous) {
      // re-render all pages at new scale
      renderContinuous();
    } else {
      // just re-apply transform in single-page mode
      applyTransform();
    }
  }

  /* =========================
     FULLSCREEN
  ========================== */
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }

  /* =========================
     PAGE NAV (BOTH MODES)
  ========================== */
  function nextPage() {
    if (pageNum < totalPages) {
      pageNum++;
      if (continuous) scrollToPage(pageNum);
      else renderSinglePage();
    }
  }

  function prevPage() {
    if (pageNum > 1) {
      pageNum--;
      if (continuous) scrollToPage(pageNum);
      else renderSinglePage();
    }
  }

  function scrollToPage(n) {
    const c = viewer.querySelector(`.pageCanvas[data-page="${n}"]`);
    if (!c) return;
    container.scrollTo({ top: c.offsetTop - 10, behavior: 'smooth' });
    indicator.textContent = `Page ${n} / ${totalPages}`;
  }

  /* =========================
     PAN / DRAG (SINGLE PAGE ONLY)
  ========================== */
  let dragging = false;
  let startX, startY;

  container.addEventListener('pointerdown', e => {
    if (continuous) return;
    dragging = true;
    viewer.classList.add('dragging');
    startX = e.clientX - targetX;
    startY = e.clientY - targetY;
  });

  window.addEventListener('pointermove', e => {
    if (!dragging || continuous) return;
    targetX = e.clientX - startX;
    targetY = e.clientY - startY;
    applyTransform();
  });

  window.addEventListener('pointerup', () => {
    dragging = false;
    viewer.classList.remove('dragging');
  });

  /* =========================
     DESKTOP WHEEL ZOOM (SINGLE PAGE ONLY)
  ========================== */
  container.addEventListener('wheel', e => {
    if (continuous) return; // in continuous, wheel scrolls normally
    e.preventDefault();
    const delta = e.deltaY < 0 ? 0.08 : -0.08;
    setScale(scale + delta);
  }, { passive: false });

  /* =========================
     MOBILE PINCH ZOOM (SINGLE PAGE ONLY)
  ========================== */
  let lastDistance = null;

  container.addEventListener('touchstart', e => {
    if (continuous) return;
    if (e.touches.length === 2) {
      lastDistance = getDistance(e.touches[0], e.touches[1]);
    }
  }, { passive: false });

  container.addEventListener('touchmove', e => {
    if (continuous) return;
    if (e.touches.length === 2 && lastDistance !== null) {
      e.preventDefault();
      const currentDistance = getDistance(e.touches[0], e.touches[1]);
      const delta = (currentDistance - lastDistance) * 0.0012;
      setScale(scale + delta);
      lastDistance = currentDistance;
    }
  }, { passive: false });

  container.addEventListener('touchend', () => {
    lastDistance = null;
  });

  function getDistance(t1, t2) {
    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
  }

  // Expose functions for inline onclick
  window.zoomIn = zoomIn;
  window.zoomOut = zoomOut;
  window.toggleFullscreen = toggleFullscreen;
  window.nextPage = nextPage;
  window.prevPage = prevPage;
  window.toggleContinuous = toggleContinuous;
</script>

</body>
</html>
